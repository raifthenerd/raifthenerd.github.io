<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=/favicon.svg rel=icon type=image/svg+xml><link rel="alternate icon" href=/favicon.png type=image/png><link href=/css/katex.min.css rel=stylesheet><script defer src=/js/katex.min.js></script><script defer onload=renderMathInElement(document.body); src=/js/auto-render.min.js></script><script src=/js/vega.min.js></script><script src=/js/vega-lite.min.js></script><script src=/js/vega-embed.min.js></script><link href=/css/default.css rel=stylesheet><script async crossorigin data-category=Comments data-category-id=DIC_kwDOGkX-x84CAY8r data-emit-metadata=0 data-input-position=top data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=raifthenerd/raifthenerd.github.io data-repo-id=R_kgDOGkX-xw data-theme=light src=https://giscus.app/client.js></script><script src="https://www.googletagmanager.com/gtag/js?id=G-XXY96K3XP3" async></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date());gtag('config','G-XXY96K3XP3')</script><script async data-ad-client=ca-pub-5141260618801038 src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><link href=https://blog.raifthenerd.com/atom.xml rel=alternate title=Feeds type=application/atom+xml><meta content=website property=og:type><meta content=https://blog.raifthenerd.com/cpython-mem-gc/ property=og:url><meta content=.sh property=og:site_name><meta content=summary name=twitter:card><title>CPython Internals: Garbage Collection Basics ― .sh</title><meta content="CPython Internals: Garbage Collection Basics ― .sh" property=og:title><meta content="CPython Internals: Garbage Collection Basics ― .sh" name=twitter:title><meta content="Reference counting system and reference cycle detection algorithm of CPython's GC module." name=description><meta content="Reference counting system and reference cycle detection algorithm of CPython's GC module." property=og:description><meta content="Reference counting system and reference cycle detection algorithm of CPython's GC module." name=twitter:description><meta content=https://blog.raifthenerd.com/2022-01-02-cpython-mem-gc/thumbnail.png name=twitter:image><meta content=https://blog.raifthenerd.com/2022-01-02-cpython-mem-gc/thumbnail.png property=og:image><body><header aria-label="main navigation" class="navbar is-transparent" role=navigation><div class="navbar-brand container is-max-widescreen"><div class=navbar-brand><a class="navbar-item has-text-weight-bold is-uppercase" href=https://blog.raifthenerd.com> .sh </a></div></div></header><section class=section><article class="container is-max-widescreen"><div class="columns is-variable is-8-widescreen"><header class=column><h1 class="title is-2">CPython Internals: Garbage Collection Basics</h1><p class="subtitle is-6"><time datetime=2022-01-02>2022-01-02</time><hr></header></div><div class="columns is-variable is-8-widescreen"><aside class="menu column is-one-quarter is-one-third-widescreen is-hidden-touch"><p class=menu-label>Table of Contents<ul class=menu-list><li><a href=https://blog.raifthenerd.com/cpython-mem-gc/#review-basics-of-garbage-collection>Review: Basics of Garbage Collection</a><li><a href=https://blog.raifthenerd.com/cpython-mem-gc/#reference-counting>Reference Counting</a><li><a href=https://blog.raifthenerd.com/cpython-mem-gc/#extra-memory-layout-for-reference-cycle-detection>Extra Memory Layout for Reference Cycle Detection</a><li><a href=https://blog.raifthenerd.com/cpython-mem-gc/#identifying-reference-cycles>Identifying Reference Cycles</a><li><a href=https://blog.raifthenerd.com/cpython-mem-gc/#references>References</a></ul></aside><div class="content column"><p>CPython manages the memory by using a garbage collector, where the garbage collector relies on the reference counting with a cycle detection algorithm.</p><span id=continue-reading></span><p><em>All codes in this post are based on <a href=https://github.com/python/cpython/tree/v3.10.0>CPython v3.10</a>.</em><h2 id=review-basics-of-garbage-collection>Review: Basics of Garbage Collection</h2><p>Manually managing the dynamic memory area is a risky approach becaus of mistakes that are highly prone to occur. For instance, the program may free the memory that is being used (<em>dangling pointer</em>), or may continue to occupy the unused memory area (<em>memory leak</em>). To prevent these errors as possible, modern programming languages have a memory management system that automatically frees the memory blocks.<p><img alt="GC's view of memory as a directed graph. © Randal E. Bryant & David R. O'Hallaron." src=https://blog.raifthenerd.com/cpython-mem-gc/garbage-collector.png><p>A <em>garbage collector</em> (GC) is a system that periodically frees the <em>unreachable</em> memory. Since the unreachable memories can never be used anymore, it's safe to free the garbage at any point in time. To effectively free the unreachable memories, GC internally maintains the auxiliary status of memory reachability.<h2 id=reference-counting>Reference Counting</h2><p>Most basic method is <em>reference counting</em>. All CPython objects <code>PyObject</code> have a field <code>ob_refcnt</code> that stores the number of references that point to themselves.<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#017c9d>typedef struct</span><span> _object {
</span><span>    Py_ssize_t ob_refcnt;   </span><span style=color:#b8b6b1>// reference count
</span><span>    PyTypeObject </span><span style=color:#017c9d>*</span><span>ob_type;  </span><span style=color:#b8b6b1>// pointer to concrete type
</span><span>} PyObject;
</span><span>
</span><span style=color:#017c9d>typedef struct</span><span> _typeobject {
</span><span>    PyObject </span><span style=color:#017c9d>*</span><span>tp_alloc(PyTypeObject </span><span style=color:#017c9d>*</span><span>, Py_ssize_t);
</span><span>
</span><span>    </span><span style=color:#017c9d>int </span><span>tp_is_gc(PyObject </span><span style=color:#017c9d>*</span><span>);
</span><span>    </span><span style=color:#017c9d>int </span><span>tp_clear(PyObject </span><span style=color:#017c9d>*</span><span>);
</span><span>
</span><span>    </span><span style=color:#017c9d>void </span><span>tp_dealloc(PyObject </span><span style=color:#017c9d>*</span><span>)
</span><span>    </span><span style=color:#017c9d>void </span><span>tp_finalized(PyObject </span><span style=color:#017c9d>*</span><span>)
</span><span>    </span><span style=color:#017c9d>void </span><span>tp_free(</span><span style=color:#017c9d>void *</span><span>);  </span><span style=color:#b8b6b1>// low-level free-memory routine
</span><span>
</span><span>    </span><span style=color:#b8b6b1>// call visitproc for all referencing objects
</span><span>    </span><span style=color:#017c9d>int </span><span>tp_traverse(PyObject </span><span style=color:#017c9d>*</span><span>, visitproc, </span><span style=color:#017c9d>void *</span><span>);
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>} PyTypeObject;
</span><span>
</span><span style=color:#017c9d>typedef int </span><span>(</span><span style=color:#017c9d>*</span><span>visitproc)(PyObject </span><span style=color:#017c9d>*</span><span>, </span><span style=color:#017c9d>void *</span><span>);
</span></code></pre><p>When the <code>ob_refcnt</code> becomes 0, it implies that the object is unreachable and thus CPython immediately deallocates the occupied memory area. It seems nice, but the problem is that it cannot handle <em>reference cycles</em>:<pre class=language-python data-lang=python style=background:#fff;color:#414f5c><code class=language-python data-lang=python><span style=color:#017c9d>>>> </span><span>container </span><span style=color:#017c9d>= </span><span>[]
</span><span style=color:#017c9d>>>> </span><span>container.append(container)
</span><span style=color:#017c9d>>>> </span><span>sys.getrefcount(container)
</span><span style=color:#15b8ae>3
</span><span style=color:#017c9d>>>> </span><span style=color:#dcdbd9>del </span><span>container  </span><span style=color:#b8b6b1># never falls to 0 due to its own internal reference
</span></code></pre><p>One could think that cycles are uncommon, but in reality, there are lots of cycles generated from several causes:<ul><li>Data structures like graphs.<li>Instances have references to their class. The class references its module and the module contains references to <em>everything</em> that is inside, so this can lead back to the original instance.<li>Exceptions. They contain traceback that contain a list of frames that contain the exception itself.<li>Module-level functions. To resolve global variables, they reference the module which contains references to module-level functions.</ul><p>Therefore, CPython has <code>gc</code> module for detecting the reference cycle. The main process is defined in <code>Modules/gcmodule.c</code>:L1180-1357.<h2 id=extra-memory-layout-for-reference-cycle-detection>Extra Memory Layout for Reference Cycle Detection</h2><p>In order to support the reference cycle detection, the memory layout of objects is altered to accommodate extra information <em>before</em> the normal layout. The additional data store in the head are:<ul><li>Pointer for previous and next objects.<li>Temporal copy of a reference count.<li>Bit masks to denote several statuses. <ul><li><code>PREV_MASK_COLLECTING</code>: whether an object has not been visited yet.<li><code>NEXT_MASK_UNREACHABLE</code> whether an object is tentatively unreachable.<li><code>_PyGC_PREV_MASK_FINALIZED</code>: whether an object has been already finalized.</ul></ul><pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#017c9d>typedef struct </span><span>{
</span><span>    </span><span style=font-style:italic;color:#019d76>uintptr_t</span><span> _gc_next;
</span><span>    </span><span style=font-style:italic;color:#019d76>uintptr_t</span><span> _gc_prev;
</span><span>} PyGC_Head;  </span><span style=color:#b8b6b1>// CPython reuses these fields to hold all necessary info
</span><span>
</span><span style=color:#017c9d>#define </span><span>_PyGC_PREV_SHIFT           (</span><span style=color:#15b8ae>2</span><span>)
</span><span style=color:#017c9d>#define </span><span>_PyGC_PREV_MASK_FINALIZED  (</span><span style=color:#15b8ae>1</span><span>)
</span><span style=color:#017c9d>#define </span><span>PREV_MASK_COLLECTING       (</span><span style=color:#15b8ae>2</span><span>)
</span><span style=color:#017c9d>#define </span><span>NEXT_MASK_UNREACHABLE      (</span><span style=color:#15b8ae>1</span><span>)
</span></code></pre><p>To employ the extra information, CPython provides two macros (<code>AS_GC</code> and <code>FROM_GC</code>) and wrapper for <code>pymalloc</code> (<code>_PyObject_GC_Alloc</code>).<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#017c9d>#define </span><span style=color:#15b8ae>AS_GC</span><span>(</span><span style=font-style:italic;color:#414f5c>o</span><span>) ((PyGC_Head </span><span style=color:#017c9d>*</span><span>)(o)</span><span style=color:#017c9d>-</span><span style=color:#15b8ae>1</span><span>)
</span><span style=color:#017c9d>#define </span><span style=color:#15b8ae>FROM_GC</span><span>(</span><span style=font-style:italic;color:#414f5c>g</span><span>) ((PyObject </span><span style=color:#017c9d>*</span><span>)(((PyGC_Head </span><span style=color:#017c9d>*</span><span>)g)</span><span style=color:#017c9d>+</span><span style=color:#15b8ae>1</span><span>))
</span><span>
</span><span style=color:#019d76>static</span><span> PyObject </span><span style=color:#017c9d>* </span><span style=color:#15b8ae>_PyObject_GC_Alloc</span><span>(</span><span style=color:#017c9d>int </span><span style=font-style:italic;color:#414f5c>use_calloc</span><span>, </span><span style=font-style:italic;color:#019d76>size_t </span><span style=font-style:italic;color:#414f5c>basicsize</span><span>) {
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>
</span><span>    </span><span style=font-style:italic;color:#019d76>size_t</span><span> size </span><span style=color:#017c9d>= sizeof</span><span>(PyGC_Head) </span><span style=color:#017c9d>+</span><span> basicsize;
</span><span>    PyGC_Head </span><span style=color:#017c9d>*</span><span>g </span><span style=color:#017c9d>= </span><span>(PyGC_Head </span><span style=color:#017c9d>*</span><span>)PyObject_Malloc(size);
</span><span>    g->_gc_next </span><span style=color:#017c9d>= </span><span style=color:#15b8ae>0</span><span>;
</span><span>    g->_gc_prev </span><span style=color:#017c9d>= </span><span style=color:#15b8ae>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>
</span><span>    PyObject </span><span style=color:#017c9d>*</span><span>op </span><span style=color:#017c9d>= </span><span>FROM_GC(g);
</span><span>    </span><span style=color:#017c9d>return</span><span> op;
</span><span>}
</span></code></pre><h2 id=identifying-reference-cycles>Identifying Reference Cycles</h2><p>The code for finding reference cycles is <code>deduce_unreachable</code> at <code>Modules/gcmodule.c</code>:L1069-1146, which requires two disjoint doubly-linked lists as parameters:<ul><li><code>base</code>: a list contains objects to be scanned.<li><code>unreachable</code>: another list contains objects <em>tentatively</em> unreachable.</ul><pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#019d76>static inline </span><span style=color:#017c9d>void </span><span style=color:#15b8ae>deduce_unreachable</span><span>(PyGC_Head </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>base</span><span>,
</span><span>                                      PyGC_Head </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>unreachable</span><span>) {
</span><span>    update_refs(base);                    </span><span style=color:#b8b6b1>// gc_prev is used for gc_refs
</span><span>    subtract_refs(base);
</span><span>    gc_list_init(unreachable);
</span><span>    move_unreachable(base, unreachable);  </span><span style=color:#b8b6b1>// gc_prev is pointer again
</span><span>}
</span></code></pre><p>When the GC starts, it scans all the container objects in <code>base</code> and initializes <code>PyGC_Head</code> via <code>gc_reset_refs</code>. The initialization step updates GC's <code>_gc_prev</code> field (<code>gc_ref</code> in the figure) by copying the value of the original reference count <code>ob_refcnt</code> in <code>PyObject</code> (<code>ref count</code> in the figures).<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#019d76>static </span><span style=color:#017c9d>void </span><span style=color:#15b8ae>update_refs</span><span>(PyGC_Head </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>containers</span><span>) {
</span><span>    PyGC_Head </span><span style=color:#017c9d>*</span><span>gc </span><span style=color:#017c9d>= </span><span>GC_NEXT(containers);
</span><span>    </span><span style=color:#017c9d>for </span><span>(; gc </span><span style=color:#017c9d>!=</span><span> containers; gc </span><span style=color:#017c9d>= </span><span>GC_NEXT(gc))
</span><span>        gc_reset_refs(gc, Py_REFCNT(FROM_GC(gc)));
</span><span>}
</span><span>
</span><span style=color:#019d76>static inline </span><span style=color:#017c9d>void </span><span style=color:#15b8ae>gc_reset_refs</span><span>(PyGC_Head </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>g</span><span>, Py_ssize_t </span><span style=font-style:italic;color:#414f5c>refs</span><span>) {
</span><span>    g->_gc_prev </span><span style=color:#017c9d>= </span><span>(g->_gc_prev </span><span style=color:#017c9d>&</span><span> _PyGC_PREV_MASK_FINALIZED)
</span><span>        </span><span style=color:#017c9d>|</span><span> PREV_MASK_COLLECTING                           </span><span style=color:#b8b6b1>// set collecting flag
</span><span>        </span><span style=color:#017c9d>| </span><span>((</span><span style=font-style:italic;color:#019d76>uintptr_t</span><span>)(refs) </span><span style=color:#017c9d><<</span><span> _PyGC_PREV_SHIFT);       </span><span style=color:#b8b6b1>// reset refcount
</span><span>}
</span></code></pre><p>Consider the following memory status as an example.<p><img alt="Garbage collection: update_refs. © Pablo Galindo Salgado." src=https://blog.raifthenerd.com/cpython-mem-gc/cpython-gc-step0.png><p>GC then iterates <code>base</code> and decrements the reference count of any other object that the container is <em>directly</em> pointing. After all the objects have been scanned, only the objects that have references from outside will have <code>gc_refs > 0</code>.<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#019d76>static </span><span style=color:#017c9d>void </span><span style=color:#15b8ae>subtract_refs</span><span>(PyGC_Head </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>containers</span><span>) {
</span><span>    PyGC_Head </span><span style=color:#017c9d>*</span><span>gc </span><span style=color:#017c9d>= </span><span>GC_NEXT(containers);
</span><span>    </span><span style=color:#017c9d>for </span><span>(; gc </span><span style=color:#017c9d>!=</span><span> containers; gc </span><span style=color:#017c9d>= </span><span>GC_NEXT(gc)) {
</span><span>        PyObject </span><span style=color:#017c9d>*</span><span>op </span><span style=color:#017c9d>= </span><span>FROM_GC(gc);
</span><span>        (Py_TYPE(op)->tp_traverse)(
</span><span>            FROM_GC(gc),
</span><span>            (visitproc)visit_decref,
</span><span>            op);
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#019d76>static </span><span style=color:#017c9d>int </span><span style=color:#15b8ae>visit_decref</span><span>(PyObject </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>op</span><span>, </span><span style=color:#017c9d>void *</span><span style=font-style:italic;color:#414f5c>parent</span><span>) {
</span><span>    PyGC_Head </span><span style=color:#017c9d>*</span><span>gc </span><span style=color:#017c9d>= </span><span>AS_GC(op);
</span><span>    </span><span style=color:#017c9d>if </span><span>(gc_is_collecting(gc)) gc_decref(gc);
</span><span>    </span><span style=color:#017c9d>return </span><span style=color:#15b8ae>0</span><span>;
</span><span>}
</span></code></pre><p>After applying <code>subtract_refs</code>, the memory is in a state as shown in the following figure. Note that, as you can see below, <code>gc_refs == 0</code> <em>does not</em> imply that the object is unreachable.<p><img alt="Garbage collection: step 1. © Pablo Galindo Salgado." src=https://blog.raifthenerd.com/cpython-mem-gc/cpython-gc-step1.png><p>Finally, GC finds all unreachable objects by calling <code>move_unreachable</code>. <code>move_unreachable</code> re-scans all objects in <code>base</code> and does the following:<ul><li>When encounters an object with <code>gc_refs > 0</code>, first it marks the object as reachable. Then, it traverses all objects that are <em>directly reachable</em> from the object and does the following: <ul><li>Increases <code>gc_refs</code> if <code>gc_refs == 0</code>, so the objects can be marked as reachable later.<li>If some objects are in <code>unreachable</code>, move to <code>base</code>.</ul><li>When encounters an object with <code>gc_refs == 0</code>, it moves the object from <code>base</code> to <code>unreachable</code> and mark as unreachable.</ul><p>Once all the objects are scanned, the GC knows that all container objects in <code>unreachable</code> are actually unreachable and can thus be collected.<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#b8b6b1>// some variable names differ from original codes, to enhance human readability
</span><span style=color:#019d76>static </span><span style=color:#017c9d>void </span><span style=color:#15b8ae>move_unreachable</span><span>(PyGC_Head </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>base</span><span>, PyGC_Head </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>unreachable</span><span>) {
</span><span>    PyGC_Head </span><span style=color:#017c9d>*</span><span>prev </span><span style=color:#017c9d>=</span><span> base; PyGC_Head </span><span style=color:#017c9d>*</span><span>curr </span><span style=color:#017c9d>= </span><span>GC_NEXT(base);
</span><span>    </span><span style=color:#017c9d>while </span><span>(curr </span><span style=color:#017c9d>!=</span><span> base) {
</span><span>        </span><span style=color:#017c9d>if </span><span>(gc_get_refs(curr)) {  </span><span style=color:#b8b6b1>// gc_ref > 0
</span><span>            PyObject </span><span style=color:#017c9d>*</span><span>op </span><span style=color:#017c9d>= </span><span>FROM_GC(curr);
</span><span>            (Py_TYPE(op)->tp_traverse)(
</span><span>                FROM_GC(curr),
</span><span>                visit_reachable,
</span><span>                (</span><span style=color:#017c9d>void *</span><span>)base);
</span><span>
</span><span>            _PyGCHead_SET_PREV(curr, prev);  </span><span style=color:#b8b6b1>// relink gc_prev to prev element.
</span><span>            gc_clear_collecting(curr);       </span><span style=color:#b8b6b1>// mark as visited
</span><span>            prev </span><span style=color:#017c9d>=</span><span> curr;
</span><span>        } </span><span style=color:#017c9d>else </span><span>{  </span><span style=color:#b8b6b1>// gc_ref == 0
</span><span>            prev->_gc_next </span><span style=color:#017c9d>=</span><span> curr->_gc_next;
</span><span>            </span><span style=color:#b8b6b1>// no need to curr->next->prev = prev because it is single linked
</span><span>
</span><span>            </span><span style=color:#b8b6b1>// moves curr from base to unreachable & mark as unreachable.
</span><span>            PyGC_Head </span><span style=color:#017c9d>*</span><span>last </span><span style=color:#017c9d>= </span><span>GC_PREV(unreachable);
</span><span>            last->_gc_next </span><span style=color:#017c9d>= </span><span>(NEXT_MASK_UNREACHABLE </span><span style=color:#017c9d>| </span><span>(</span><span style=font-style:italic;color:#019d76>uintptr_t</span><span>)curr);
</span><span>            _PyGCHead_SET_PREV(curr, last);
</span><span>            curr->_gc_next </span><span style=color:#017c9d>= </span><span>(NEXT_MASK_UNREACHABLE </span><span style=color:#017c9d>| </span><span>(</span><span style=font-style:italic;color:#019d76>uintptr_t</span><span>)unreachable);
</span><span>            unreachable->_gc_prev </span><span style=color:#017c9d>= </span><span>(</span><span style=font-style:italic;color:#019d76>uintptr_t</span><span>)curr;
</span><span>        }
</span><span>        curr </span><span style=color:#017c9d>= </span><span>(PyGC_Head</span><span style=color:#017c9d>*</span><span>)prev->_gc_next;
</span><span>    }
</span><span>    base->_gc_prev </span><span style=color:#017c9d>= </span><span>(</span><span style=font-style:italic;color:#019d76>uintptr_t</span><span>)prev;
</span><span>    </span><span style=color:#b8b6b1>// don't let the pollution of the list head's next pointer leak
</span><span>    unreachable->_gc_next </span><span style=color:#017c9d>&= ~</span><span>NEXT_MASK_UNREACHABLE;
</span><span>}
</span><span>
</span><span style=color:#019d76>static </span><span style=color:#017c9d>int </span><span style=color:#15b8ae>visit_reachable</span><span>(PyObject </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>op</span><span>, PyGC_Head </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>reachable</span><span>) {
</span><span>    PyGC_Head </span><span style=color:#017c9d>*</span><span>gc </span><span style=color:#017c9d>= </span><span>AS_GC(op); </span><span style=color:#019d76>const</span><span> Py_ssize_t gc_refs </span><span style=color:#017c9d>= </span><span>gc_get_refs(gc);
</span><span>    </span><span style=color:#017c9d>if </span><span>(</span><span style=color:#017c9d>! </span><span>gc_is_collecting(gc)) </span><span style=color:#017c9d>return </span><span style=color:#15b8ae>0</span><span>;  </span><span style=color:#b8b6b1>// ignore visited objects
</span><span>
</span><span>    </span><span style=color:#017c9d>if </span><span>(gc->_gc_next </span><span style=color:#017c9d>&</span><span> NEXT_MASK_UNREACHABLE) {  </span><span style=color:#b8b6b1>// object in unreachable
</span><span>        </span><span style=color:#b8b6b1>/* remove current object from unreachable */
</span><span>        PyGC_Head </span><span style=color:#017c9d>*</span><span>prev </span><span style=color:#017c9d>= </span><span>GC_PREV(gc);
</span><span>        PyGC_Head </span><span style=color:#017c9d>*</span><span>next </span><span style=color:#017c9d>= </span><span>(PyGC_Head</span><span style=color:#017c9d>*</span><span>)(gc->_gc_next </span><span style=color:#017c9d>& ~</span><span>NEXT_MASK_UNREACHABLE);
</span><span>        prev->_gc_next </span><span style=color:#017c9d>=</span><span> gc->_gc_next;
</span><span>        _PyGCHead_SET_PREV(next, prev);
</span><span>
</span><span>        </span><span style=color:#b8b6b1>/* ... and append to base */
</span><span>        gc_list_append(gc, reachable);
</span><span>
</span><span>        gc_set_refs(gc, </span><span style=color:#15b8ae>1</span><span>);
</span><span>    } </span><span style=color:#017c9d>else if </span><span>(gc_refs </span><span style=color:#017c9d>== </span><span style=color:#15b8ae>0</span><span>) {  </span><span style=color:#b8b6b1>// object in base and gc_ref == 0
</span><span>        gc_set_refs(gc, </span><span style=color:#15b8ae>1</span><span>);
</span><span>    }
</span><span>    </span><span style=color:#017c9d>return </span><span style=color:#15b8ae>0</span><span>;
</span><span>}
</span></code></pre><p>Following image depicts the state of the lists in a moment when the GC processed the <code>link_3</code> and <code>link_4</code> but has not processed <code>link_1</code> and <code>link_2</code> yet.<p><img alt="Garbage collection: step 2. © Pablo Galindo Salgado." src=https://blog.raifthenerd.com/cpython-mem-gc/cpython-gc-step2.png><p>Then GC scans <code>link_1</code> and marks as reachable.<p><img alt="Garbage collection: step 3. © Pablo Galindo Salgado." src=https://blog.raifthenerd.com/cpython-mem-gc/cpython-gc-step3.png><p>After that, GC scans <code>link_2</code> and this moves <code>link_3</code> from <code>unreachable</code> to <code>base</code>. GC finally scans <code>link_3</code> and mark it as reachable and the process is finished.<p><img alt="Garbage collection: step 4. © Pablo Galindo Salgado." src=https://blog.raifthenerd.com/cpython-mem-gc/cpython-gc-step4.png><p>Note that no recursion is required by any of this process, and neither does it in any other way require additional memory, except for \(O(1)\) storage for internal C needs.<h2 id=references>References</h2><ul><li>Randal E. Bryant and David R. O'Hallaron, <em>Computer Systems: A Programmer's Perspective</em> (3/E).<li>Pablo Galindo Salgado, <a href=https://devguide.python.org/garbage_collector/>Design of CPython's Garbage Collector</a></ul></div></div><div class="columns is-variable is-8-widescreen"><article class="giscus column"></article></div></article></section><footer class="footer mt-auto"><div class="container is-max-widescreen"><div class="image is-96x96 ml-auto mr-auto"><img alt="ascii kitten" src=/nyan.svg></div><div class="has-text-centered is-size-7"><small> © <a rel="author external" href=https://github.com/raifthenerd/raifthenerd>Seokjin Han</a> 2022. All contents on this website is licensed under <a rel="license external" href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>. <br> <a href=/policy rel=license>Privacy Policy</a> </small></div></div></footer>