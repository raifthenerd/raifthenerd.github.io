<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=/favicon.svg rel=icon type=image/svg+xml><link rel="alternate icon" href=/favicon.png type=image/png><link href=/css/katex.min.css rel=stylesheet><script defer src=/js/katex.min.js></script><script defer onload=renderMathInElement(document.body); src=/js/auto-render.min.js></script><script src=/js/vega.min.js></script><script src=/js/vega-lite.min.js></script><script src=/js/vega-embed.min.js></script><link href=/css/default.css rel=stylesheet><script async crossorigin data-category=Comments data-category-id=DIC_kwDOGkX-x84CAY8r data-emit-metadata=0 data-input-position=top data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=raifthenerd/raifthenerd.github.io data-repo-id=R_kgDOGkX-xw data-theme=light src=https://giscus.app/client.js></script><script src="https://www.googletagmanager.com/gtag/js?id=G-XXY96K3XP3" async></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date());gtag('config','G-XXY96K3XP3')</script><script async data-ad-client=ca-pub-5141260618801038 src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><link href=https://blog.raifthenerd.com/atom.xml rel=alternate title=Feeds type=application/atom+xml><meta content=website property=og:type><meta content=https://blog.raifthenerd.com/cpython-frontend/ property=og:url><meta content=.sh property=og:site_name><meta content=summary name=twitter:card><title>CPython Internals: Frontend of Bytecode Compiler ― .sh</title><meta content="CPython Internals: Frontend of Bytecode Compiler ― .sh" property=og:title><meta content="CPython Internals: Frontend of Bytecode Compiler ― .sh" name=twitter:title><meta content="How CPython understand the Python syntax and parse the code?" name=description><meta content="How CPython understand the Python syntax and parse the code?" property=og:description><meta content="How CPython understand the Python syntax and parse the code?" name=twitter:description><meta content=https://blog.raifthenerd.com/2022-02-05-cpython-frontend/thumbnail.png name=twitter:image><meta content=https://blog.raifthenerd.com/2022-02-05-cpython-frontend/thumbnail.png property=og:image><body><header aria-label="main navigation" class="navbar is-transparent" role=navigation><div class="navbar-brand container is-max-widescreen"><div class=navbar-brand><a class="navbar-item has-text-weight-bold is-uppercase" href=https://blog.raifthenerd.com> .sh </a></div></div></header><section class=section><article class="container is-max-widescreen"><div class="columns is-variable is-8-widescreen"><header class=column><h1 class="title is-2">CPython Internals: Frontend of Bytecode Compiler</h1><p class="subtitle is-6"><time datetime=2022-02-05>2022-02-05</time><hr></header></div><div class="columns is-variable is-8-widescreen"><aside class="menu column is-one-quarter is-one-third-widescreen is-hidden-touch"><p class=menu-label>Table of Contents<ul class=menu-list><li><a href=https://blog.raifthenerd.com/cpython-frontend/#review-compiler-organization>Review: Compiler Organization</a> <ul><li><a href=https://blog.raifthenerd.com/cpython-frontend/#frontend-parser-type-checker>Frontend: Parser & Type Checker</a><li><a href=https://blog.raifthenerd.com/cpython-frontend/#backend-ir-generator-optimizers-code-generator>Backend: IR Generator, Optimizers & Code Generator</a></ul><li><a href=https://blog.raifthenerd.com/cpython-frontend/#specification>Specification</a> <ul><li><a href=https://blog.raifthenerd.com/cpython-frontend/#comparison-between-ll-1-vs-peg>Comparison Between LL(1) vs. PEG</a></ul><li><a href=https://blog.raifthenerd.com/cpython-frontend/#entrypoints-to-cpython-tokenizers-parsers>Entrypoints to CPython Tokenizers/Parsers</a><li><a href=https://blog.raifthenerd.com/cpython-frontend/#source-code-to-tokens>Source Code to Tokens</a><li><a href=https://blog.raifthenerd.com/cpython-frontend/#tokens-to-abstract-syntax-tree>Tokens to Abstract Syntax Tree</a><li><a href=https://blog.raifthenerd.com/cpython-frontend/#reference>Reference</a></ul></aside><div class="content column"><p>Typically, compilers consist of two parts: a frontend and a backend. This post will cover the frontend of CPython's bytecode compiler, or "how CPython understand the human-readable code?"</p><span id=continue-reading></span><p><em>All codes in this post are based on <a href=https://github.com/python/cpython/tree/v3.10.0>CPython v3.10</a>.</em><h2 id=review-compiler-organization>Review: Compiler Organization</h2><p>Typically, compilers consist of following components:<p><img alt="Compiler organization. © Jeehoon Kang" src=https://blog.raifthenerd.com/cpython-frontend/compiler-organization.png><h3 id=frontend-parser-type-checker>Frontend: Parser & Type Checker</h3><p><em>Parser</em> generates the <em>abstract syntax tree</em> (AST) from the raw source code. An AST is a tree representation of source code that reflecting the grammatical aspects into the structure. Each interior node represents an operation while its children represent the arguments. The AST is used intensively during various static analysis, <em>e.g.</em>, type checking.<p>For instance, the following Python snippet<pre class=language-python data-lang=python style=background:#fff;color:#414f5c><code class=language-python data-lang=python><span style=color:#019d76>print</span><span>(</span><span style=color:#15b8ae>'Hello, World!'</span><span>)
</span></code></pre><p>is converted into the following AST:<p><img alt="The abstract syntax tree, parsed from above code snippet." src=https://blog.raifthenerd.com/cpython-frontend/ast.png><h3 id=backend-ir-generator-optimizers-code-generator>Backend: IR Generator, Optimizers & Code Generator</h3><p>Instead of directly translating to machine-readable code, many compilers generate an intermediate representation (IR), which we can think of as a program for an abstract machine. An IR is designed to be conducive for further optimization steps.<p>Note that there might exist various levels of intermediate representations, such as <a href=https://en.wikipedia.org/wiki/Control-flow_graph>control flow graphs</a> (CFG) and <a href=https://en.wikipedia.org/wiki/Register_machine>register machines</a>.<p>Lastly, the IR is translated to the machine-readable code. While most compilers generate machine codes that targeting the specific <em>physical</em> architectures (<em>e.g.</em>, x86, ARM, ...), CPython translates the IR into the <em>bytecode</em>, which is executed via CPython virtual machine later.<h2 id=specification>Specification</h2><p>The grammar of Python can be found in following files:<ul><li><code>Grammar/Tokens</code> contains the token specification.<li><code>Grammar/python.gram</code> contains the grammar specification, specified using <a href=https://en.wikipedia.org/wiki/Parsing_expression_grammar>parser expression grammar</a> (PEG), with corresponding AST nodes. <ul><li>PEG parser is introduced since CPython v3.9. Before v3.9, CPython used <a href=https://en.wikipedia.org/wiki/LL_parser>LL(1) parser</a>. See <a href=https://blog.raifthenerd.com/cpython-frontend/#comparison-between-ll-1-vs-peg>below</a> for details.</ul><li><code>Parser/Python.asdl</code> contains the specification of the AST, specified using <a href=https://dl.acm.org/doi/10.5555/1267950.1267967>Zephyr Abstract Syntax Definition Language</a>. <ul><li>The definition is independent of its realization in <em>any</em> particular programming language.</ul></ul><p>Note that various files, including the source code of the parser, are automatically generated from these definitions. Thus, whenever you changed the syntactic definition, you should re-generate those files via running following commands:<pre class=language-bash data-lang=bash style=background:#fff;color:#414f5c><code class=language-bash data-lang=bash><span style=color:#b8b6b1># regenerates Include/token.h, Parser/token.c, Lib/token.py
</span><span style=color:#b8b6b1># from Grammar/Tokens
</span><span style=color:#b8b6b1># using Tools/scripts/generate_token.py:
</span><span style=color:#017c9d>></span><span> make regen-token
</span><span style=color:#b8b6b1># regenerates Parser/parser.c
</span><span style=color:#b8b6b1># from Grammar/python.gram and Grammar/Tokens
</span><span style=color:#b8b6b1># using Tools/peg_generator/pegen:
</span><span style=color:#017c9d>></span><span> make regen-pegen
</span><span style=color:#b8b6b1># regenerate Include/Python-ast.h and Python/Python-ast.c
</span><span style=color:#b8b6b1># from Parser/Python.asdl
</span><span style=color:#b8b6b1># using Parser/asdl_c.py:
</span><span style=color:#017c9d>></span><span> make regen-ast
</span></code></pre><h3 id=comparison-between-ll-1-vs-peg>Comparison Between LL(1) vs. PEG</h3><p>LL(1) is a kind of <a href=https://en.wikipedia.org/wiki/Context-free_grammar>context-free grammar</a> (CFG). CFG is used by lots of programming languages, although it has some critical limitations. Two problems, ambiguous rules and inability to left-recursive rules, is pointed out in <a href=https://www.python.org/dev/peps/pep-0617/>PEP-617</a>. Although the problems <em>might</em> be avoided by generating equivalent LL(1) rules, it may be harder for programmers to catch its meaning.<p>PEG, on the other hand, cannot suffer from the ambiguity. In addition, while general PEG does not support the left-recursion, CPython's parser allows us to write left-recursive rules. It may include not only the direct recursions, but also complicated rules with indirect or hidden left-recursions.<p>More details can be found on <a href=https://devguide.python.org/parser/>CPython devguide</a>.<h2 id=entrypoints-to-cpython-tokenizers-parsers>Entrypoints to CPython Tokenizers/Parsers</h2><p>There are multiple ways to execute CPython binary, stated in <code>pymain_run_python</code> function defined in <code>Modules/main.c</code>:<ul><li>Execute with a command via <code>-c</code> argument, <em>e.g</em>, <code>python -c "print(1 + 3)"</code><li>Execute a module via <code>-m</code> argument, <em>e.g.</em>, <code>python -m http.server</code><li>Execute a script file<li>Execute with a command via stdin, <em>e.g.</em>, <code>echo "print(1 + 3)" | python</code><li>Execute without any arguments to open up the REPL</ul><pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#019d76>static </span><span style=color:#017c9d>void </span><span style=color:#15b8ae>pymain_run_python</span><span>(</span><span style=color:#017c9d>int *</span><span style=font-style:italic;color:#414f5c>exitcode</span><span>) {
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>    PyInterpreterState </span><span style=color:#017c9d>*</span><span>interp </span><span style=color:#017c9d>= </span><span>_PyInterpreterState_GET();
</span><span>    PyConfig </span><span style=color:#017c9d>*</span><span>config </span><span style=color:#017c9d>= </span><span>(PyConfig</span><span style=color:#017c9d>*</span><span>)_PyInterpreterState_GetConfig(interp);
</span><span>
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>    </span><span style=color:#017c9d>if </span><span>(config->run_command) {
</span><span>        </span><span style=color:#017c9d>*</span><span>exitcode </span><span style=color:#017c9d>= </span><span>pymain_run_command(config->run_command);
</span><span>    } </span><span style=color:#017c9d>else if </span><span>(config->run_module) {
</span><span>        </span><span style=color:#017c9d>*</span><span>exitcode </span><span style=color:#017c9d>= </span><span>pymain_run_module(config->run_module, </span><span style=color:#15b8ae>1</span><span>);
</span><span>    } </span><span style=color:#017c9d>else if </span><span>(main_importer_path </span><span style=color:#017c9d>!= </span><span style=color:#019d76>NULL</span><span>) {
</span><span>        </span><span style=color:#017c9d>*</span><span>exitcode </span><span style=color:#017c9d>= </span><span>pymain_run_module(</span><span style=color:#017c9d>L</span><span style=color:#15b8ae>"__main__"</span><span>, </span><span style=color:#15b8ae>0</span><span>);
</span><span>    } </span><span style=color:#017c9d>else if </span><span>(config->run_filename </span><span style=color:#017c9d>!= </span><span style=color:#019d76>NULL</span><span>) {
</span><span>        </span><span style=color:#017c9d>*</span><span>exitcode </span><span style=color:#017c9d>= </span><span>pymain_run_file(config);
</span><span>    } </span><span style=color:#017c9d>else </span><span>{
</span><span>        </span><span style=color:#017c9d>*</span><span>exitcode </span><span style=color:#017c9d>= </span><span>pymain_run_stdin(config);
</span><span>    }
</span><span>    pymain_repl(config, exitcode);
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>}
</span></code></pre><p>For each method, CPython calls different tokenizers and/or parsers.<ul><li>All <code>pymain_run_file</code>, <code>pymain_run_stdin</code> and <code>pymain_repl</code> rely on <code>_PyRun_AnyFileObject</code>, which uses <code>_PyParser_ASTFromFile</code>.<li><code>_PyParser_ASTFromString</code> is called when CPython is executed via <code>pymain_run_command</code>.<li>When executing via <code>pymain_run_module</code>, CPython wraps the module using <code>runpy._run_code</code>, which loads the code objects via built-in <code>exec</code>. If the module has not been compiled yet, CPython runs <code>compile</code> on the module, which calls <code>_PyParser_ASTFromString</code> (see <code>builtin_compile_impl</code> in <code>Python/bltinmodule.c</code>).</ul><h2 id=source-code-to-tokens>Source Code to Tokens</h2><p>First of all, the source code is grouped into meaningful sequences of <em>tokens</em>. Each token can have a token name and an optional attribute value. For instance, the code<pre class=language-python data-lang=python style=background:#fff;color:#414f5c><code class=language-python data-lang=python><span style=color:#019d76>print</span><span>(</span><span style=color:#15b8ae>'Hello, World!'</span><span>)
</span></code></pre><p>can be tokenized into:<pre style=background:#fff;color:#414f5c><code><span>0,0-0,0:            ENCODING       'utf-8'
</span><span>1,0-1,5:            NAME           'print'
</span><span>1,5-1,6:            OP             '('
</span><span>1,6-1,21:           STRING         "'Hello, World!'"
</span><span>1,21-1,22:          OP             ')'
</span><span>1,22-1,23:          NEWLINE        '\n'
</span><span>2,0-2,0:            ENDMARKER      ''
</span></code></pre><p>Parser consumes those tokens and builds the AST. If you're interested in how the CPython tokenizer works, see <code>tok_get</code> function defined in <code>Parser/tokenizer.c</code>, or see <a href=https://benjam.info/blog/posts/2019-09-18-python-deep-dive-tokenizer/>the excellent post by Benjamin Woodruff</a>. This post won't cover the tedious details :)<p><img alt="Simplified structure of CPython tokenizer. © Benjamin Woodruff" src=https://blog.raifthenerd.com/cpython-frontend/tokenizer.png><h2 id=tokens-to-abstract-syntax-tree>Tokens to Abstract Syntax Tree</h2><p>Both <code>_PyParser_ASTFromString</code> and <code>_PyParser_ASTFromFile</code> are thin wrapper of <code>_PyPegen_run_parser</code>, which internally calls <code>_PyPegen_parse</code> in <code>Grammar/python.gram</code>:<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#017c9d>void* </span><span style=color:#15b8ae>_PyPegen_parse</span><span>(Parser </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>p</span><span>) {
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>    </span><span style=color:#017c9d>void *</span><span>result </span><span style=color:#017c9d>= </span><span style=color:#019d76>NULL</span><span>;
</span><span>    </span><span style=color:#017c9d>if </span><span>(p->start_rule </span><span style=color:#017c9d>==</span><span> Py_file_input) {
</span><span>        result </span><span style=color:#017c9d>= </span><span>file_rule(p);
</span><span>    } </span><span style=color:#017c9d>else if </span><span>(p->start_rule </span><span style=color:#017c9d>==</span><span> Py_single_input) {
</span><span>        result </span><span style=color:#017c9d>= </span><span>interactive_rule(p);
</span><span>    } </span><span style=color:#017c9d>else if </span><span>(p->start_rule </span><span style=color:#017c9d>==</span><span> Py_eval_input) {
</span><span>        result </span><span style=color:#017c9d>= </span><span>eval_rule(p);
</span><span>    } </span><span style=color:#017c9d>else if </span><span>(p->start_rule </span><span style=color:#017c9d>==</span><span> Py_func_type_input) {
</span><span>        result </span><span style=color:#017c9d>= </span><span>func_type_rule(p);
</span><span>    } </span><span style=color:#017c9d>else if </span><span>(p->start_rule </span><span style=color:#017c9d>==</span><span> Py_fstring_input) {
</span><span>        result </span><span style=color:#017c9d>= </span><span>fstring_rule(p);
</span><span>    }
</span><span>    </span><span style=color:#017c9d>return</span><span> result;
</span><span>}
</span></code></pre><p>Each rule function generates an AST tree until all non-terminal symbols are replaced and returns its root node. AST nodes are C structs generated from their definition. For instance, <code>file_rule</code> returns the following struct representing the mod node<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#017c9d>enum </span><span>_mod_kind {
</span><span>    Module_kind</span><span style=color:#017c9d>=</span><span style=color:#15b8ae>1</span><span>,
</span><span>    Interactive_kind</span><span style=color:#017c9d>=</span><span style=color:#15b8ae>2</span><span>,
</span><span>    Expression_kind</span><span style=color:#017c9d>=</span><span style=color:#15b8ae>3</span><span>,
</span><span>    FunctionType_kind</span><span style=color:#017c9d>=</span><span style=color:#15b8ae>4
</span><span>};
</span><span style=color:#017c9d>struct </span><span>_mod {
</span><span>    </span><span style=color:#017c9d>enum</span><span> _mod_kind kind;
</span><span>    </span><span style=color:#017c9d>union </span><span>{
</span><span>        </span><span style=color:#017c9d>struct </span><span>{
</span><span>            asdl_stmt_seq </span><span style=color:#017c9d>*</span><span>body;
</span><span>            asdl_type_ignore_seq </span><span style=color:#017c9d>*</span><span>type_ignores;
</span><span>        } Module;
</span><span>
</span><span>        </span><span style=color:#017c9d>struct </span><span>{
</span><span>            asdl_stmt_seq </span><span style=color:#017c9d>*</span><span>body;
</span><span>        } Interactive;
</span><span>
</span><span>        </span><span style=color:#017c9d>struct </span><span>{
</span><span>            expr_ty body;
</span><span>        } Expression;
</span><span>
</span><span>        </span><span style=color:#017c9d>struct </span><span>{
</span><span>            asdl_expr_seq </span><span style=color:#017c9d>*</span><span>argtypes;
</span><span>            expr_ty returns;
</span><span>        } FunctionType;
</span><span>
</span><span>    } v;
</span><span>};
</span></code></pre><p>which is generated from the following definition:<pre class=language-asdl data-lang=asdl style=background:#fff;color:#414f5c><code class=language-asdl data-lang=asdl><span>mod = Module(stmt* body, type_ignore* type_ignores)
</span><span>    | Interactive(stmt* body)
</span><span>    | Expression(expr body)
</span><span>    | FunctionType(expr* argtypes, expr returns)
</span></code></pre><p>Notice that <code>_PyPegen_run_parser</code> might call <code>_PyPegen_parse</code> twice if the first attempt has failed. This is because the second parsing can use additional rules thus the error report can be enhanced. Since using these custom rules has severe degradation, CPython applies these rules only if an error occurs.<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#017c9d>void * </span><span style=color:#15b8ae>_PyPegen_run_parser</span><span>(Parser </span><span style=color:#017c9d>*</span><span style=font-style:italic;color:#414f5c>p</span><span>) {
</span><span>    </span><span style=color:#017c9d>void *</span><span>res </span><span style=color:#017c9d>= </span><span>_PyPegen_parse(p);
</span><span>    </span><span style=color:#017c9d>if </span><span>(res </span><span style=color:#017c9d>== </span><span style=color:#019d76>NULL</span><span>) {  </span><span style=color:#b8b6b1>// parser has failed
</span><span>        </span><span style=color:#b8b6b1>// some exception has been raised
</span><span>        </span><span style=color:#017c9d>if </span><span>(PyErr_Occurred() </span><span style=color:#017c9d>&& !</span><span>PyErr_ExceptionMatches(PyExc_SyntaxError))
</span><span>            </span><span style=color:#017c9d>return </span><span style=color:#019d76>NULL</span><span>;
</span><span>
</span><span>        </span><span style=color:#b8b6b1>// reset parser and parse again
</span><span>        Token </span><span style=color:#017c9d>*</span><span>last_token </span><span style=color:#017c9d>=</span><span> p->tokens[p->fill </span><span style=color:#017c9d>- </span><span style=color:#15b8ae>1</span><span>];
</span><span>        reset_parser_state(p);
</span><span>        _PyPegen_parse(p);
</span><span>        </span><span style=color:#b8b6b1>/* ... */
</span><span>
</span><span>        </span><span style=color:#b8b6b1>// notice that the second attempt always failed
</span><span>        </span><span style=color:#017c9d>return </span><span style=color:#019d76>NULL</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>}
</span></code></pre><p>The rules for the error reports starts with <code>invalid_</code>. For instance, the following rule<pre class=language-asdl data-lang=asdl style=background:#fff;color:#414f5c><code class=language-asdl data-lang=asdl><span>invalid_kwarg:
</span><span>    | a=NAME b='=' expression for_if_clauses {
</span><span>        RAISE_SYNTAX_ERROR_KNOWN_RANGE(a, b,
</span><span>            "invalid syntax. Maybe you meant '==' or ':=' instead of '='?")}
</span><span>    | !(NAME '=') a=expression b='=' {
</span><span>        RAISE_SYNTAX_ERROR_KNOWN_RANGE(
</span><span>            a, b,
</span><span>            "expression cannot contain assignment, perhaps you meant \"==\"?")}
</span></code></pre><p>will be raised in the following situations:<pre class=language-python data-lang=python style=background:#fff;color:#414f5c><code class=language-python data-lang=python><span style=color:#017c9d>>>> </span><span>x </span><span style=color:#017c9d>= </span><span style=color:#15b8ae>3
</span><span style=color:#017c9d>>>> if </span><span>x = </span><span style=color:#15b8ae>3</span><span>: x </span><span style=color:#017c9d>+= </span><span style=color:#15b8ae>1
</span><span>  File </span><span style=color:#15b8ae>"&LTstdin>"</span><span>, line </span><span style=color:#15b8ae>1
</span><span>    </span><span style=color:#017c9d>if </span><span>x = </span><span style=color:#15b8ae>3</span><span>: x </span><span style=color:#017c9d>+= </span><span style=color:#15b8ae>1
</span><span>       </span><span style=color:#017c9d>^^^^^
</span><span style=font-style:italic;color:#019d76>SyntaxError</span><span>: invalid syntax. Maybe you meant </span><span style=color:#15b8ae>'==' </span><span style=color:#017c9d>or </span><span style=color:#15b8ae>':=' </span><span>instead of </span><span style=color:#15b8ae>'='</span><span>?
</span><span style=color:#017c9d>>>> </span><span>y </span><span style=color:#017c9d>= </span><span style=font-style:italic;color:#019d76>dict</span><span>(</span><span style=color:#15b8ae>1</span><span>=</span><span style=color:#15b8ae>2</span><span>)
</span><span>  File </span><span style=color:#15b8ae>"&LTstdin>"</span><span>, line </span><span style=color:#15b8ae>1
</span><span>    y </span><span style=color:#017c9d>= </span><span style=font-style:italic;color:#019d76>dict</span><span>(</span><span style=color:#15b8ae>1</span><span>=</span><span style=color:#15b8ae>2</span><span>)
</span><span>             </span><span style=color:#017c9d>^^
</span><span style=font-style:italic;color:#019d76>SyntaxError</span><span>: expression cannot contain assignment, perhaps you meant </span><span style=color:#15b8ae>"=="</span><span>?
</span></code></pre><h2 id=reference>Reference</h2><ul><li>Various resources on compilers <ul><li>Alfred V. Aho and others, <em>Compilers: Principles, Techniques, and Tools</em> (2/E).<li><a href=https://github.com/kaist-cp/cs420>KAIST CS420: Compiler Design</a></ul><li>Various articles from CPython Devguide <ul><li><a href=https://devguide.python.org/grammar/>Changing CPython's Grammar</a><li><a href=https://devguide.python.org/parser/>Guide to CPython's Parser</a><li><a href=https://devguide.python.org/compiler>Design of CPython's Compiler</a></ul><li>Benjamin Woodruff, <a href=https://benjam.info/blog/posts/2019-09-18-python-deep-dive-tokenizer/>A Deep Dive into Python's Tokenizer</a>.</ul></div></div><div class="columns is-variable is-8-widescreen"><article class="giscus column"></article></div></article></section><footer class="footer mt-auto"><div class="container is-max-widescreen"><div class="image is-96x96 ml-auto mr-auto"><img alt="ascii kitten" src=/nyan.svg></div><div class="has-text-centered is-size-7"><small> © <a rel="author external" href=https://github.com/raifthenerd/raifthenerd>Seokjin Han</a> 2022. All contents on this website is licensed under <a rel="license external" href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>. <br> <a href=/policy rel=license>Privacy Policy</a> </small></div></div></footer>