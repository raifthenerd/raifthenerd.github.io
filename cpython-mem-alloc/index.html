<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><link href=/favicon.svg rel=icon type=image/svg+xml><link rel="alternate icon" href=/favicon.png type=image/png><link href=/css/katex.min.css rel=stylesheet><script defer src=/js/katex.min.js></script><script defer onload=renderMathInElement(document.body); src=/js/auto-render.min.js></script><script src=/js/vega.min.js></script><script src=/js/vega-lite.min.js></script><script src=/js/vega-embed.min.js></script><link href=/css/default.css rel=stylesheet><script async crossorigin data-category=Comments data-category-id=DIC_kwDOGkX-x84CAY8r data-emit-metadata=0 data-input-position=top data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=raifthenerd/raifthenerd.github.io data-repo-id=R_kgDOGkX-xw data-theme=light src=https://giscus.app/client.js></script><script src="https://www.googletagmanager.com/gtag/js?id=G-XXY96K3XP3" async></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date());gtag('config','G-XXY96K3XP3')</script><script async data-ad-client=ca-pub-5141260618801038 src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><link href=https://blog.raifthenerd.com/atom.xml rel=alternate title=Feeds type=application/atom+xml><meta content=website property=og:type><meta content=https://blog.raifthenerd.com/cpython-mem-alloc/ property=og:url><meta content=.sh property=og:site_name><meta content=summary name=twitter:card><title>CPython Internals: Memory Allocation ― .sh</title><meta content="CPython Internals: Memory Allocation ― .sh" property=og:title><meta content="CPython Internals: Memory Allocation ― .sh" name=twitter:title><meta content="Algorithm of CPython's default allocator, intended for small Python objects with short lifecycle." name=description><meta content="Algorithm of CPython's default allocator, intended for small Python objects with short lifecycle." property=og:description><meta content="Algorithm of CPython's default allocator, intended for small Python objects with short lifecycle." name=twitter:description><meta content=https://blog.raifthenerd.com/2022-01-01-cpython-mem-alloc/thumbnail.png name=twitter:image><meta content=https://blog.raifthenerd.com/2022-01-01-cpython-mem-alloc/thumbnail.png property=og:image><body><header aria-label="main navigation" class="navbar is-transparent" role=navigation><div class="navbar-brand container is-max-widescreen"><div class=navbar-brand><a class="navbar-item has-text-weight-bold is-uppercase" href=https://blog.raifthenerd.com> .sh </a></div></div></header><section class=section><article class="container is-max-widescreen"><div class="columns is-variable is-8-widescreen"><header class=column><h1 class="title is-2">CPython Internals: Memory Allocation</h1><p class="subtitle is-6"><time datetime=2022-01-01>2022-01-01</time><hr></header></div><div class="columns is-variable is-8-widescreen"><aside class="menu column is-one-quarter is-one-third-widescreen is-hidden-touch"><p class=menu-label>Table of Contents<ul class=menu-list><li><a href=https://blog.raifthenerd.com/cpython-mem-alloc/#review-memory-layout-of-linux-process>Review: Memory Layout of Linux Process</a><li><a href=https://blog.raifthenerd.com/cpython-mem-alloc/#allocator-domains-of-cpython>Allocator Domains of CPython</a><li><a href=https://blog.raifthenerd.com/cpython-mem-alloc/#memory-allocation-algorithm-of-pymalloc>Memory allocation algorithm of pymalloc</a> <ul><li><a href=https://blog.raifthenerd.com/cpython-mem-alloc/#arena>Arena</a><li><a href=https://blog.raifthenerd.com/cpython-mem-alloc/#pools>Pools</a><li><a href=https://blog.raifthenerd.com/cpython-mem-alloc/#blocks>Blocks</a></ul><li><a href=https://blog.raifthenerd.com/cpython-mem-alloc/#reference>Reference</a></ul></aside><div class="content column"><p>CPython has several memory allocators, intended to used for different domains. <code>pymalloc</code> is the main allocator that operates differently from well-known <code>malloc</code> and <code>free</code>.</p><span id=continue-reading></span><p><em>All codes in this post are based on <a href=https://github.com/python/cpython/tree/v3.10.0>CPython v3.10</a>.</em><h2 id=review-memory-layout-of-linux-process>Review: Memory Layout of Linux Process</h2><p><img alt="Process virtual address space of Linux process. © Randal E. Bryant & David R. O'Hallaron." src=https://blog.raifthenerd.com/cpython-mem-alloc/memory-layout.png><p>Each process has the same uniform view of memory, which is known as its <em>virtual address space</em>. The virtual address space seen by each process consists of a number of areas, each with a specific purpose. When programs require more memories, they request an additional memory area, usually located between the user stack and the program data.<p>Linux provides two system calls for this purpose:<ul><li><code>sbrk</code> changes the <em>break pointer</em>, so the program can use the so-called <em>heap</em> area (the area between the break pointer and the program data).<li><code>mmap</code> explicitly request a new memory area.</ul><p>Most C Programs use the <code>malloc</code> and <code>free</code> to dynamically manage the additional memory, which internally uses <code>sbrk</code>. However, CPython uses a different approach called <code>pymalloc</code>.<h2 id=allocator-domains-of-cpython>Allocator Domains of CPython</h2><p>All allocating functions of CPython belong to one of three different <em>domains</em> (see <code>Include/cpython/pymem.h</code>:L23-L32 for details)<ul><li>Object domain: intended for Python objects.<li>"Mem" domain: intended for Python buffers and general-purpose memory buffers where the allocation must be performed with the GIL held.<li>Raw domain: intended for general-purpose memory buffers where the allocation must go to the system allocator or where the allocator can operate without the GIL.</ul><p>These domains represent different allocation strategies and are optimized for different purposes. Internally, CPython uses two functions to take a memory; system's <code>malloc</code> and Python's <code>pymalloc</code>.<table><thead><tr><th>Configuration<th>Raw domain<th>"Mem" domain<th>Object domain<tbody><tr><td>Release<td><code>malloc</code><td><code>pymalloc</code><td><code>pymalloc</code><tr><td>Debug<td><code>malloc</code> + debug<td><code>pymalloc</code> + debug<td><code>pymalloc</code> + debug<tr><td>Release, w/o pymalloc<td><code>malloc</code><td><code>malloc</code><td><code>malloc</code><tr><td>Debug, w/o pymalloc<td><code>malloc</code> + debug<td><code>malloc</code> + debug<td><code>malloc</code> + debug</table><p><code>pymalloc</code> is optimized for small objects (smaller or equal to 512 bytes) with a short lifetime. It falls back to <code>malloc</code> for allocations larger than 512 bytes.<h2 id=memory-allocation-algorithm-of-pymalloc>Memory allocation algorithm of <code>pymalloc</code></h2><p><code>pyalloc</code> first takes a large memory chunk from system, and internally manages all objects and data structures inside the chunk. The memory chunk is called an <em>arena</em>, and each arena consists of <em>pools</em> and <em>blocks</em>.<h3 id=arena>Arena</h3><p><img alt="Structure of pymalloc arena. © Alexander VanTol" src=https://blog.raifthenerd.com/cpython-mem-alloc/cpython-arena.png><p>Arenas are the largest chunks of memory and are aligned on a page boundary in memory, where CPython assumes the system's page size is 256kB. Note that arenas are the only things that can truly be freed.<p>Arenas can be organized into a (doubly) linked list. In fact, CPython manages three lists of arenas:<ul><li><code>arenas</code> (<code>Objects/obmalloc.c</code>:L1212): list of all arenas.<li><code>unused_arena_object</code> (<code>Objects/obmalloc.c</code>:L1219): list of every empty arenas.<li><code>usable_arenas</code> (<code>Objects/obmalloc.c</code>:L1224): arenas with pools available, maintained in increasing order of <code>nfreepools</code> (see next section for details).</ul><pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#017c9d>struct </span><span>arena_object {
</span><span>    </span><span style=font-style:italic;color:#019d76>uintptr_t</span><span> address;
</span><span>    </span><span style=color:#017c9d>struct </span><span>arena_object* nextarena;
</span><span>    </span><span style=color:#017c9d>struct </span><span>arena_object* prevarena;
</span><span>    </span><span style=font-style:italic;color:#019d76>uint</span><span> nfreepools;
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>};
</span></code></pre><p>New arenas can be allocated via <code>new_arena()</code> (<code>Objects/obmalloc.c</code>:L1533). When the <code>new_arena()</code> is initially called, it allocates 16 arenas, and doubles the number of arenas for each subsequent calls.<p>The arena allocator internally uses the following functions:<ul><li><code>VirtualAlloc()</code>/<code>VirtualFree()</code> on Windows,<li><code>mmap()</code>/<code>munmap()</code> if available,<li><code>malloc()</code>/<code>free()</code> otherwise.</ul><h3 id=pools>Pools</h3><p><img alt="Structure of pymalloc pools. © Alexander VanTol" src=https://blog.raifthenerd.com/cpython-mem-alloc/cpython-pools.png><p>An arena is composed of 64 pools (<em>i.e.</em>, size of each pool is 4kB), where each pool can only store blocks with predefined sizes. For instance, if the size class index of a pool is 3, it can store only 25-32 byte of blocks. Each pool maintains a double-linked list to other pools of the same size class.<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#017c9d>struct </span><span>arena_object {
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>    </span><span style=font-style:italic;color:#019d76>uint</span><span> ntotalpools;
</span><span>    </span><span style=color:#017c9d>struct </span><span>pool_header* freepools;
</span><span>    block</span><span style=color:#017c9d>*</span><span> pool_address;
</span><span>};
</span><span>
</span><span style=color:#017c9d>struct </span><span>pool_header {
</span><span>    </span><span style=color:#017c9d>struct </span><span>pool_header *nextpool;       </span><span style=color:#b8b6b1>/* next pool of this size class  */
</span><span>    </span><span style=color:#017c9d>struct </span><span>pool_header *prevpool;       </span><span style=color:#b8b6b1>/* previous pool       ""        */
</span><span>    </span><span style=font-style:italic;color:#019d76>uint</span><span> arenaindex;                    </span><span style=color:#b8b6b1>/* index into arenas of base adr */
</span><span>    </span><span style=font-style:italic;color:#019d76>uint</span><span> szidx;                         </span><span style=color:#b8b6b1>/* block size class index        */
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>};
</span><span style=color:#017c9d>typedef struct</span><span> pool_header </span><span style=color:#017c9d>*</span><span>poolp;
</span></code></pre><p>Pools themselves must be in one of three states:<ul><li>Used: Some block is used and available blocks exist.<li>Full: Every block is used so no available block exists.<li>Empty: No data is stored, so any size class can be assigned.</ul><p>To track the pool, CPython manages <code>usedpools</code> and <code>freepools</code> variables. When a given block size is requested, CPython checks available pools in <code>usedpools</code>. If no pool is found, initialize an empty pool in <code>freepools</code> with the size class and add to <code>usedpools</code> for its size class.<h3 id=blocks>Blocks</h3><p><img alt="Structure of pymalloc blocks. © Alexander VanTol" src=https://blog.raifthenerd.com/cpython-mem-alloc/cpython-blocks.png><p>Structure of blocks is simple; it's just a memory address.<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#017c9d>struct </span><span>pool_header {
</span><span>    </span><span style=color:#b8b6b1>/* ... */
</span><span>    </span><span style=color:#017c9d>union </span><span>{ block </span><span style=color:#017c9d>*</span><span>_padding;
</span><span>            </span><span style=font-style:italic;color:#019d76>uint</span><span> count; } ref;          </span><span style=color:#b8b6b1>/* number of allocated blocks    */
</span><span>    block </span><span style=color:#017c9d>*</span><span>freeblock;                   </span><span style=color:#b8b6b1>/* pool's free list head         */
</span><span>    </span><span style=font-style:italic;color:#019d76>uint</span><span> nextoffset;                    </span><span style=color:#b8b6b1>/* bytes to virgin block         */
</span><span>    </span><span style=font-style:italic;color:#019d76>uint</span><span> maxnextoffset;                 </span><span style=color:#b8b6b1>/* largest valid nextoffset      */
</span><span>};
</span><span>
</span><span style=color:#017c9d>typedef </span><span style=font-style:italic;color:#019d76>uint8_t </span><span>block;
</span></code></pre><p>Similar to the pool, blocks can have one of the three states:<ul><li>Untouched: Blocks have not been allocated.<li>Free: Blocks had allocated but <em>freed</em> later by CPython.<li>Allocated: Blocks allocated.</ul><p>Note that each pool has a pointer <code>freeblock</code>. As CPython makes a block <em>free</em>, the block is filled with previous <code>freeblock</code> value while <code>freeblock</code> is filled with the address of this newly free block. In other words, <code>freeblock</code> points to a singly linked list of free blocks of the pool.<pre class=language-c data-lang=c style=background:#fff;color:#414f5c><code class=language-c data-lang=c><span style=color:#019d76>static inline </span><span style=color:#017c9d>void* </span><span style=color:#15b8ae>pymalloc_alloc</span><span>(</span><span style=color:#017c9d>void *</span><span style=font-style:italic;color:#414f5c>ctx</span><span>, </span><span style=font-style:italic;color:#019d76>size_t </span><span style=font-style:italic;color:#414f5c>nbytes</span><span>) {
</span><span>    </span><span style=color:#017c9d>if </span><span>(UNLIKELY(nbytes </span><span style=color:#017c9d>== </span><span style=color:#15b8ae>0</span><span>)) </span><span style=color:#017c9d>return </span><span style=color:#019d76>NULL</span><span>;
</span><span>    </span><span style=color:#017c9d>if </span><span>(UNLIKELY(nbytes </span><span style=color:#017c9d>></span><span> SMALL_REQUEST_THRESHOLD)) </span><span style=color:#017c9d>return </span><span style=color:#019d76>NULL</span><span>;
</span><span>
</span><span>    </span><span style=font-style:italic;color:#019d76>uint</span><span> size </span><span style=color:#017c9d>= </span><span>(</span><span style=font-style:italic;color:#019d76>uint</span><span>)(nbytes </span><span style=color:#017c9d>- </span><span style=color:#15b8ae>1</span><span>) </span><span style=color:#017c9d>>></span><span> ALIGNMENT_SHIFT;
</span><span>    poolp pool </span><span style=color:#017c9d>=</span><span> usedpools[size </span><span style=color:#017c9d>+</span><span> size];
</span><span>    block </span><span style=color:#017c9d>*</span><span>bp;
</span><span>
</span><span>    </span><span style=color:#017c9d>if </span><span>(LIKELY(pool </span><span style=color:#017c9d>!=</span><span> pool->nextpool)) {
</span><span>        </span><span style=color:#b8b6b1>// used pool exists for this size class
</span><span>        bp </span><span style=color:#017c9d>=</span><span> pool->freeblock;
</span><span>        </span><span style=color:#019d76>assert</span><span>(bp </span><span style=color:#017c9d>!= </span><span style=color:#019d76>NULL</span><span>);
</span><span>        </span><span style=color:#017c9d>if </span><span>(UNLIKELY((pool->freeblock </span><span style=color:#017c9d>= *</span><span>(block </span><span style=color:#017c9d>**</span><span>)bp) </span><span style=color:#017c9d>== </span><span style=color:#019d76>NULL</span><span>)) {
</span><span>            </span><span style=color:#b8b6b1>// exausted freeblock
</span><span>            pymalloc_pool_extend(pool, size);
</span><span>        }
</span><span>    } </span><span style=color:#017c9d>else </span><span>{  </span><span style=color:#b8b6b1>// no used pool exists; allocate new one from freepools
</span><span>        bp </span><span style=color:#017c9d>= </span><span>allocate_from_new_pool(size);
</span><span>    }
</span><span>    </span><span style=color:#017c9d>return </span><span>(</span><span style=color:#017c9d>void *</span><span>)bp;
</span><span>}
</span><span>
</span><span style=color:#019d76>static </span><span style=color:#017c9d>void </span><span style=color:#15b8ae>pymalloc_pool_extend</span><span>(poolp </span><span style=font-style:italic;color:#414f5c>pool</span><span>, </span><span style=font-style:italic;color:#019d76>uint </span><span style=font-style:italic;color:#414f5c>size</span><span>) {
</span><span>    </span><span style=color:#017c9d>if </span><span>(UNLIKELY(pool->nextoffset </span><span style=color:#017c9d><=</span><span> pool->maxnextoffset)) {
</span><span>        </span><span style=color:#b8b6b1>// untouched exists
</span><span>        pool->freeblock </span><span style=color:#017c9d>= </span><span>(block</span><span style=color:#017c9d>*</span><span>)pool </span><span style=color:#017c9d>+</span><span> pool->nextoffset;
</span><span>        pool->nextoffset </span><span style=color:#017c9d>+= </span><span>INDEX2SIZE(size);
</span><span>        </span><span style=color:#017c9d>*</span><span>(block </span><span style=color:#017c9d>**</span><span>)(pool->freeblock) </span><span style=color:#017c9d>= </span><span style=color:#019d76>NULL</span><span>;
</span><span>    } </span><span style=color:#017c9d>else </span><span>{  </span><span style=color:#b8b6b1>// full pool; unlinked to usedpools
</span><span>        poolp next;
</span><span>        next </span><span style=color:#017c9d>=</span><span> pool->nextpool; pool </span><span style=color:#017c9d>=</span><span> pool->prevpool;
</span><span>        next->prevpool </span><span style=color:#017c9d>=</span><span> pool; pool->nextpool </span><span style=color:#017c9d>=</span><span> next;
</span><span>    }
</span><span>}
</span></code></pre><h2 id=reference>Reference</h2><ul><li>Randal E. Bryant and David R. O'Hallaron, <em>Computer Systems: A Programmer's Perspective</em> (3/E).<li>Alexander VanTol, <a href=https://realpython.com/python-memory-management/>Memory Management in Python</a>.</ul></div></div><div class="columns is-variable is-8-widescreen"><article class="giscus column"></article></div></article></section><footer class="footer mt-auto"><div class="container is-max-widescreen"><div class="image is-96x96 ml-auto mr-auto"><img alt="ascii kitten" src=/nyan.svg></div><div class="has-text-centered is-size-7"><small> © <a rel="author external" href=https://github.com/raifthenerd/raifthenerd>Seokjin Han</a> 2022. All contents on this website is licensed under <a rel="license external" href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>. <br> <a href=/policy rel=license>Privacy Policy</a> </small></div></div></footer>